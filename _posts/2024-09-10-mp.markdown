---
layout:     post
title:      "贪吃蛇寻路算法"
subtitle:   " \"知识回顾\""
date:       2024-09-10 12:00:00
author:     "eutopia"
header-img: "img/bk-1.jpg"
catalog: true
tags:
    - 数据结构
    - C++
---

> “Let us go！！！ ”

## 前言

这是我上学期的大作业，要求是用easyx去开发一个贪吃蛇游戏，这个项目本身的难度是不大的，再不依靠ai的情况下也能很快写完，但是后续我给它加了几个有意思的小功能，便是加入能寻找最佳路径的机器人小蛇，随机地图并且支持了双人，甚至加上ai可以实现无数多人的
但是说到底有意义去分享的只有这个寻路算法，底层思想是树和递归

--

## 正文

其实自己创建一个ai小蛇类，让它不断判断最佳路径，要求步数最少并且不会把自己绕进死路，由于地图是不规则并且玩家的干扰，这并不是一件很简单的事，这里先讲一下我首先想到的最为简单的方法

假如食物在蛇左下方，那就先向左与食物同一列，然后再向下吃到食物
假如食物在蛇右上方，那就先向右与食物同一列，然后再向上吃到食物

这个思路好像很清晰，但由于地图会绕出一部分死路，很容易就造成两种情况
- ai小蛇撞到玩家小蛇直接死亡
- 比如食物在正下方但是有墙堵着


我其实是加了一个保护机制，如果蛇本身预定的路线可能会死亡，那就会强行改变为不会出现死路的方向，但是，没错还有但是，这种机制下ai小蛇在遇到很多情况都会出现原地打转，保护机制告诉它一定要向右，但是寻路机制马上又把它带回来，
周而复始，到这里我也发现了，如果要让小蛇实现在不同复杂的地形都能找到正确的路，要不只能通过大量的if语句。要不只能每次都计算完整的最佳路径保证两种机制的平衡

接下来的思路的灵感来源于过河卒和贪心算法，方法主要是四叉树的遍历和递归

贪心算法总结一下便是每一次都选择最优的情况那么最后的结果就是最优的情况，过河卒这里不另做介绍，因为下面便是它的变形

假设地图由一张字符二维表构成，蛇头为'@'，墙壁为'#'，蛇身为'='，食物为'*'




![1](https://github.com/dreameutopia/dreameutopia.github.io/blob/master/img/step1.jpg)

我们首先来分析一下，我们的起始点就是@，目标是*，中间要避开=和#，那么我们就在创建一个int形的二维数组，@的位置设置为1，=和#设置为-1，其他位置初始化为0，第一次给1周围相邻的四个格子设置为1+1=2,第二次就给这四个格子相连的格子赋值为2+1=3，已经赋值过的不再一次赋值，
周而复始



