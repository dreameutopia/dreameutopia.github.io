---
layout: post
title: "Java实现局域网聊天--多线程入门"
subtitle: "Thinking in React vs. Thinking in Vue"
author: "eutopia"
header-style: text
tags:
  - Java
  - Gui
  - Thread
---

> Ai辅助开发Gui界面


好吧，实际上写到这我Java只入门了一周，但秉承着分享和记录的理念，我还是想把这个入门之作写出来，这里也是第一次感受「多线程」的魅力。

正文开始前我先声明一下，

1.  



前言
--

上个学期在c++的学习中也学习到了多线程线程锁的概念，但是还没有正式运用到一个较为正式的项目中，这里也算是加深理解的第一个小项目。这里也在强迫自己的代码变得稍微规范一点，不要像之前的屎山代码一样了哈哈哈哈。





服务器端
-------------------------------------

先来看看主线程吧

```java
public static void main(String[] args) {
        System.out.println("-------------启动服务端系统-----------------");
        try {
            //注册端口
            ServerSocket serverSocket=new ServerSocket(constant.port);
            //主线程负责接收客户端连接请求
            while(true){
                System.out.println("等待客户端连接。。。。");
                Socket socket = serverSocket.accept();
                new ServerReader(socket).start();

                System.out.println("成功接入一个客户端");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

这里通过while循环来不断接受新客户端的链接，不断创建子线程来接受处理。

### 子线程处理
```java
 @Override
    public void run(){
        try {
            //接受的消息有很多种类型 1登录类型  2 群聊消息  3 私聊消息
            //所以客户端必须申明协议发送消息
            //比如客户端先发1  代表接下来是登录消息
            //比如客户端先发1  代表接下来是群聊消息
            // 先接收一个数字  在判断，先从输入管道中接受客户端发送来的消息类型编号
            DataInputStream dis=new DataInputStream(socket.getInputStream());
            while (true) {
                int type=dis.readInt();
                switch (type){
                    case 1:
                        //客户端发来了登录消息，再更新全部在线人数列表
                        String nickname=dis.readUTF();
                        name=nickname;
                        String password=dis.readUTF();
                        System.out.println(nickname+"登录了");
                        System.out.println("开始比对--------------");
                        if(!requestiscorrect(nickname,password)){
                            DataOutputStream dos1=new DataOutputStream(socket.getOutputStream());
                            dos1.writeInt(6);//登录失败
                            continue;
                        }
                        DataOutputStream dos1=new DataOutputStream(socket.getOutputStream());
                        dos1.writeInt(7);//登录成功
                        //把这个登录成功的客户端socket存入到在线集合
                        server.onlinesocket.put(socket,nickname);

                        //更新全部客户端在线人数列表
                        updatesocketonlinelist();

                        break;
                    case 2:
                        //客户端发来了群聊消息，再把消息转发给其他所有客户端
                        String msg=dis.readUTF();
                        sendmessagetoall(msg);
                        for (Socket socket : server.onlinesocket.keySet()) {
                            try {
                                //把用户名发送给客户端
                                DataOutputStream dos=new DataOutputStream(socket.getOutputStream());
                                dos.writeInt(2);//1代表告诉客户端接下来是在线人数列表信息    2代表发送群聊消息
                                dos.writeUTF(msg);
                                dos.flush();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                        break;
                    case 3:
                        //客户端发来了私聊消息，再把消息转发给指定客户端
                        String to_nickname=dis.readUTF();
                        System.out.println("接收到私聊消息，发送至："+to_nickname);
                        String msg3=dis.readUTF();
                        //根据用户名查找到相应的管道去发送消息
                        for (Map.Entry<Socket,String> entry : server.onlinesocket.entrySet()) {
                            try {
                                System.out.println(entry.getValue());
                                System.out.println("对比"+to_nickname);
                                if(entry.getValue().equals(to_nickname)){
                                    //把用户名发送给客户端
                                    DataOutputStream dos=new DataOutputStream(entry.getKey().getOutputStream());
                                    System.out.println("匹配成功，正在发送消息");
                                    dos.writeInt(3);//1代表告诉客户端接下来是在线人数列表信息    2代表发送群聊消息
                                    StringBuilder sb2=new StringBuilder();

                                    //获取当前时间
                                    LocalDateTime now=LocalDateTime.now();
                                    DateTimeFormatter dtf=DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss EEE a");
                                    String nowstr=dtf.format(now);
                                    //拼接字符串
                                    StringBuilder msgresult=sb2.append(name).append(" ").append(nowstr).append("\r\n").append(msg3).append("\r\n");
                                    dos.writeUTF(msgresult.toString());
                                    dos.flush();
                                }

                            } catch (Exception e) {}
                        }


                        break;
                    case 5:
                        //客户端发来了注册请求，存储到内部文件中
                        String username=dis.readUTF();
                        String userpassword=dis.readUTF();
                        registerforusers(username,userpassword);
                        break;
                    default:
                        break;
                }
            }

        } catch (Exception e) {

            System.out.println("客户端断开连接了"+socket.getInetAddress().getHostAddress());
            server.onlinesocket.remove(socket);
            updatesocketonlinelist();
        }
    }
```

说到底最后选择特殊数据流去收发数据还是最为简便和有效，可以有效区分各种消息进行转发，也有利于后续功能的拓展，这里仅展示了扩展thread类重写的run方法，但也可以看出主要功能是不断接受客户端发来的信息再进行处理转发给其他客户端，这里使用StringBuilder来加速字符串拼接速度和通过LocalDateTime来获取当前时间，这里遇到了问题就是每次收发数据一定要flush一次不然可能发送或接受失败导致程序崩溃，后续我会加入线程锁来提高安全，暂时先这个样子。



客户端
-------------------------------------


```java
return (props) => <a onClick={inc}>{count.value}</a>
```

为了帮助你理解，如果我们有一门假想的 Vue 语言的话……

```ts
// hypothetical Vue lang
component Counter (props) {    // constructor
  @reactive count = 0          // field
  inc() { count.value ++ }     // method
  render() { return <a onClick={inc}>{count.value}</a> }
}
```







React, "Purely (Semi-Monadic/Algebraic) FP"
-------------------------------------------

再来看 React（本文中的 React 主要指 Hooks API 下的 React）

```ts
function Counter(props) {
  const [count, setCount] = React.useState(0);
  const inc = () => setCount(count + 1)
  return <a onClick={inc}>{count}</a>
}
```

React 为组件挑选的语义是「函数」，每次渲染都是对 `Counter` 这个函数的一次真实调用。每次 `useState` 都会执行并从 React 那取出当前的状态给 `count`，每次也都会创建一个新的 `inc` 函数（故其闭包中捕获的也是新的 `count` 值）。

React 附加的核心语义是一个副作用受控的「执行上下文（evaluation context）」，通俗得说就是 React 这个运行环境：状态 `count` 每次都要从 React 上下文中取出，`inc` 对状态更改的方式是用 `setCount` 更新上下文里的内容，状态更改的结果是这个函数会被重新调用，调用时函数就会从新的上下文中获得新的状态、进行重渲染和安排上（schedule）受上下文控制的副作用（`useEffect`) 。

为了帮助你理解，如果我们有一门假想的 React 语言的话……


```ts
// hypothetical React lang Ⅰ
component Counter = (props) =>      // function
  @context.state(1) {                  // context provides `get_or` and `put`
    count <- get_or(0)              // get from context (or use default value)
    let inc = () => put(count + 1)  // callback can update the context
    return <a onClick={inc}>{count}</a>
  }
```

是不是有基于 Monad 的 Haskell 内味了？只不过 React 把 API 做得完全不需要你弄懂这些复杂的东西[\[4\]](#ref_4)。如果你不熟悉 Monad 这个纯 FP 的概念，我们可以先不严谨[\[5\]](#ref_5)得把它当做文中的「上下文」。扔出 M-bomb 的原因是大家通常把它作为在纯 FP 中处理副作用的标杆，帮助我们展示如何把 React 归约到纯 FP。

有的同学（比如[@题叶](//www.zhihu.com/people/790dccce26904cdcd11b0fad3bac37b7)）会疑惑，这怎么跟我认得的「纯函数」不一样呢，这也是「纯函数式编程」吗？其实如果我们把语法糖展开就会变成：

```ts
component Counter = (props) =>
  context.state(1).get_or(0).then([count, put] => {  // `then` is monadic bind.
    let inc = () => put(count + 1)
    return <a onClock={inc}>{count}</a>
  }).unwrap() // assuming it's safe.
```

有没有想到同样被称作 Monad，具备异步上下文的 Promise？

再（过度）简化一些，你可以想象成最直白的 state-passing 风格（实际上 2018 年时 React 团队就这么考虑过类似的 API [\[6\]](#ref_6)，也是 Seb 的理论基础之一[\[7\]](#ref_7)）:

```ts
component Counter = (props, stateMap) => {
  let count = stateMap.get(1, or=0);
  let inc = () => stateMap.set(1, count + 1); // functional update
  return <a onClick={inc}>{count}</a>
}
```


不过，React 从实现到 API 设计都更靠近与追求[\[8\]](#ref_8)的心智模型是一个相对较新的纯 FP 概念 —— Algebraic Effect（代数作用），虽然名字听起来相当迷惑，但其实它在描述副作用上比 Monad 反而更不花哨（少一些 ceremony），理解起来也更加容易，Dan 有一篇给 JSer 看的很易懂的博文[\[9\]](#ref_9)并且有中文翻译[\[10\]](#ref_10)。我们可以先把它当作「可以重新恢复的 `try-catch` 」

为了帮助你理解，如果我们又又又又有一门假想的 React 语言的话……

```ts
// hypothetical React lang Ⅱ
component Counter = (props) => {
  let count = perform getState(1),or=0); // 1. `perform` "throw" effects to the context
                                                // 4. resume with the continuation to here
  let inc = () => perform putState(1, s=count + 1);
  return <a onClick={inc}>{count}</a>
}

// call site
try <Counter /> handle  // 2.try-handle pattern match effects
                        // 3. get state from the context and then resume
| getState(key, or) => resume with context.state(key) ?? or
| putState(key, s) => context.state(key)=s; resume with void
```

是不是有感觉一些了？我们从组件里「扔出去」去更改 「执行上下文」里的状态，然后再「恢复」回来……

即便 React 已经很努力的降低了 API 的门槛，但其思维的愈加纯函数式确实会在更多程序员眼里非常「离经叛道」。

所以为什么我们需要「纯函数式编程」？抛开大家可能已经熟悉的声明式、数据流清晰、局部推理、易于组合外，其背后的学术理论支撑使得其在编译期静态分析与优化、运行时高并发高并行友好方面都有极高的理论上限和上升空间（近年编程原理的理论研究完全是被函数式编程霸占得）

React 现在运行时侧重的核心是 cooperative multitasking（协作式多任务），来为 React 加入 concurrency（并发）、schedule（调度）等底层能力。很多同学只听说过后端的高并发，其实像多任务操作系统这样的「终极 UI」就是一个高并发且依赖诸如分时（time-slicing）、优先处理（re-priortizing）等进程调度的场景。React 希望把这些技术带给 UI 开发者（比如 Suspense，比如 Selective Hydration，比如 RN 新架构中的 Fabrics），第一步是运行时用 Fiber 架构重写不依赖原生调用栈，第二步就是用 Hooks 解决 Class API 在纯度上约束力不够的问题。不纯的组件在 React 并发模式下很容易出现数据竞态（data race）的问题。

总结起来，React 在组件方面的心智模型是「副作用受上下文托管的纯函数」，只要照着这个思路去想，就比较好理解「为什么 React 中倾向于使用不可变数据结构」、「为什么 useEffect 默认会执行 cleanup 来保持幂等性」、「为什么 React 需要 `useRef` 这样的跨渲染 ref cell 机制来做 mutable ref 」、「为什么 React 的性能优化是 `useMemo`, `Memo` 这样 FP 风格的 memoization 」、「为什么 React 需要 `useMemo` `useCallback` 来保持 referential identity 」、「为什么 React 需要用依赖列表来进行 cache invalidation」等问题了。



补充
--

2016 年底时我就觉得 React 和 Vue 的（一个）终极区别在于「可变」还是「不可变」。

![](https://pica.zhimg.com/50/v2-22e50932c60262bf381456de3017b217_720w.jpg?source=1940ef5c)

Seb 在 Hooks 发布后收到一些质疑的 brain dump[\[11\]](#ref_11) 里写到：

> It's interesting because there are really two approaches evolving. There's a **mutable + change tracking** approach and there's an **immutability + referential equality testing** approach. It's difficult to mix and match them when you build new features on top. So that's why React has been pushing a bit harder on immutability lately to be able to build on top of it. Both have various tradeoffs but others are doing good research in other areas, so we've decided to focus on this direction and see where it leads us.

不全部翻译了，说得是整个「大前端」社区里最主要的两条道路分歧：

* 可变 + 变更追踪。包括 Vue，Angular，
* 不可变 + 引用相等性。包括 React，Elm，(Flutter?)

这个分歧其实与我之前行文的侧重点「为组件挑选的语义」其实是对偶的：

* 前者是对传统 Imperative Programming（包括 OOP）思路的一种增强，加入了 Reactivity。
* 后者则是传统 Functional Programming 在 UI 开发领域的发扬光大（Functional Reactive Programming?)，只不过 React 是用一种比较「超越 JS 语言」的方式去实现得。

这两条道路从底子就很不同，所以才造成了 React 和 Vue 在大家眼里的渐行渐远吧。



补充 2
----

如果是在重度依赖 Flux (Vuex/Redux, whatever) 的场景，可能 Vue/React 会更像是一个只负责渲染的 dumb/passive layer，这种时候上文说的 Vue/React 的差异会显得不明显，因为大部分的状态管理（state management）都已经扔到更外层去做了。

不过，考虑需要组件内聚的场景（即组件自己有私有状态，需要 self-conatined）以及 React Hooks / Vue Composition APIs 开始接管更多（除状态之外的，比如 IO）副作用，这种差异只会变得越来越明显得。



以上。

参考
--

1.  JavaScript 模块化七日谈 - 黄玄的博客 Hux Blog [https://huangxuan.me/2015/07/09/js-module-7day/](https://huangxuan.me/2015/07/09/js-module-7day/)

